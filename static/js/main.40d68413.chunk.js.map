{"version":3,"sources":["ReportGrid.tsx","RequestsByLatency.tsx","App.tsx","serviceWorker.js","index.js"],"names":["ReportGrid","sections","view","Grid","item","sm","container","spacing","direction","map","title","rows","dimensions","showAxis","lg","key","Container","Typography","Paper","square","TopAxis","alignItems","name","report","Fragment","variant","Viz","SvgStyled","styled","svg","fillGaps","original","filled","bucket","length","End","Start","push","Count","Percent","View","maxLatency","rowHeight","ref","React","useCallback","element","width","getBoundingClientRect","d3","attr","x","domain","rangeRound","append","call","g","tickSize","tickFormat","n","valueOf","undefined","scale","latency","Math","pow","boxColor","maxRequests","barColor","row","selectAll","data","join","r","DurationHistogram","Data","d","text","Percentiles","p","Value","Percentile","useStyles","makeStyles","theme","createStyles","toolbar","flexGrow","a","fetch","rsp","json","reports","meta","JSON","parse","Labels","byProfile","by","console","log","group","Array","from","flatMap","Max","run","sort","b","assert","byRun","i","App","styles","useState","setReports","grouping","setGrouping","useEffect","getReports","then","unusedGrouping","CssBaseline","AppBar","position","Toolbar","className","Button","color","onClick","maxWidth","md","RequestsByLatency","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"8TA8FeA,EAlDI,SAAC,GAA+B,IAA7BC,EAA4B,EAA5BA,SAAUC,EAAkB,EAAlBA,KAC9B,OACE,kBAACC,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,IACb,kBAACF,EAAA,EAAD,CAAMG,WAAS,EAACC,QAAS,EAAGC,UAAU,OACnCP,EAASQ,KAAI,YAA4C,IAAzCC,EAAwC,EAAxCA,MAAOC,EAAiC,EAAjCA,KAAMC,EAA2B,EAA3BA,WAAYC,EAAe,EAAfA,SACxC,OACE,kBAACV,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,GAAIS,GAAI,EAAGC,IAAG,UAAKL,EAAL,MAC3B,kBAACM,EAAA,EAAD,KACE,kBAACb,EAAA,EAAD,CAAMG,WAAS,EAACE,UAAU,UACxB,kBAACL,EAAA,EAAD,CAAMG,WAAS,EAACF,MAAI,EAACC,GAAI,IACvB,kBAACF,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,EAAGU,IAAI,OACpB,kBAACC,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,KAAaP,KAGjB,kBAACP,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,GAAIU,IAAI,YACpBF,GAAY,kBAACK,EAAA,EAAD,CAAOC,QAAM,GAAC,kBAACjB,EAAKkB,QAAYR,MAGjD,kBAACT,EAAA,EAAD,CAAMG,WAAS,EAACF,MAAI,EAACC,GAAI,GAAIgB,WAAW,aAAab,UAAU,OAC5DG,EAAKF,KAAI,YAAuB,IAApBa,EAAmB,EAAnBA,KAAMC,EAAa,EAAbA,OACjB,OACE,kBAAC,IAAMC,SAAP,CAAgBT,IAAKO,GACnB,kBAACnB,EAAA,EAAD,CAAMC,MAAI,EAACE,WAAS,EAACD,GAAI,EAAGG,UAAU,OACpC,kBAACL,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,IACf,kBAACF,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,IACb,kBAACW,EAAA,EAAD,KACE,kBAACC,EAAA,EAAD,CAAYQ,QAAQ,WAAWH,MAIrC,kBAACnB,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,IACb,kBAACa,EAAA,EAAD,CAAOC,QAAM,GACX,kBAACjB,EAAKwB,IAAN,CAAUH,OAAQA,EAAQX,WAAYA,oB,6ICtEpE,IAAMe,E,MAAYC,EAAOC,IAAV,KAkGTC,EAAW,SAACC,GACd,IAAIC,EAAmB,GADc,uBAErC,YAAmBD,EAAnB,+CAA6B,CAAC,IAArBE,EAAoB,QAErBD,EAAOE,OAAS,GAAKF,EAAOA,EAAOE,OAAS,GAAGC,IAAMF,EAAOG,OAC5DJ,EAAOK,KAAK,CACRD,MAAOJ,EAAOA,EAAOE,OAAS,GAAGC,IACjCA,IAAKF,EAAOG,MACZE,MAAO,EACPC,QAAS,IAGjBP,EAAOK,KAAKJ,IAZqB,kFAcrC,OAAOD,GAQIQ,EALsB,CACjCpB,QA9GuC,SAAC,GAA+B,IAA7BqB,EAA4B,EAA5BA,WAAYC,EAAgB,EAAhBA,UA4BtD,OAAO,kBAACf,EAAD,CAAWgB,IAAKC,IAAMC,aA3BhB,SAACC,GACV,GAAgB,OAAZA,GAAqBL,EAAzB,CADqC,IAK7BM,EAAUD,EAAQE,wBAAlBD,MACFlB,EAAMoB,IACAH,GAEPI,KAAK,sBAAuB,QAC5BA,KAAK,UAJE,cAIgBH,EAJhB,YAIqC,IAAZL,IAE/BS,EAAIF,MAELG,OAAO,CAAC,EAAGX,IACXY,WAAW,CAAC,GAAIN,EAAQ,KAE7BlB,EAAIyB,OAAO,KAAKC,MAAK,SAAAC,GACjBA,EAAEN,KAAK,YAAP,sBAA+C,IAAZR,EAAnC,MACKa,KACGN,IAAWE,GACNM,SAASf,EAAY,GACrBgB,YAAW,SAAAC,GAAC,gBAAqB,IAAdA,EAAEC,UAAT,gBAKc,CAACnB,EAAYC,OAmF5DhB,IAhFmC,SAAC,GAA4B,IAA1BH,EAAyB,EAAzBA,OAAQX,EAAiB,EAAjBA,WA0D9C,OAAO,kBAACe,EAAD,CAAWgB,IAAKC,IAAMC,aAzDhB,SAACC,GACV,QAAee,IAAXtC,GAAoC,OAAZuB,EAA5B,CADqC,IAI7BC,EAAUD,EAAQE,wBAAlBD,MAEFI,EAAIF,MAELG,OAAO,CAAC,EAAGxC,EAAW6B,aACtBY,WAAW,CAAC,GAAIN,EAAQ,KAEvBlB,EAAMoB,IACAH,GACPI,KAAK,sBAAuB,iBAC5BA,KAAK,UAHE,cAGgBH,EAHhB,YAGyBnC,EAAW8B,YAE1CoB,EAAQ,SAACC,GAAD,OAAqBC,KAAKC,IAAIF,EAAS,EAAI,IACnDG,EAAWjB,IACIA,KAChBG,OAAO,CAAC,EAAGU,EAAMlD,EAAWuD,eAC3BC,EAAWnB,IACCA,IAAgB,IAC7BG,OAAO,CAAC,KAAM,KAAM,KAAM,KAAM,SAE/BiB,EAAMxC,EACPyB,OAAO,KACPJ,KAAK,YAFE,kBAGPoB,UAAU,KACVC,KAAK,CAAChD,IACNiD,KAAK,KAEVH,EACKf,OAAO,KACPgB,UAAU,QACVC,MAAK,SAAAE,GAAC,OAAI3C,EAAS2C,EAAEC,kBAAkBC,SACvCH,KAAK,QACLtB,KAAK,KAAK,SAAA0B,GAAC,OAAIzB,EAAEyB,EAAExC,OAAS,KAC5Bc,KAAK,SAAS,SAAA0B,GAAC,OAAIzB,EAAEyB,EAAEzC,KAAOgB,EAAEyB,EAAExC,UAClCc,KAAK,SAAUtC,EAAW8B,WAC1BQ,KAAK,QAAQ,SAAA0B,GAAC,OAAIV,EAASJ,EAAMc,EAAEtC,WACnCgB,OAAO,SACPuB,MAAK,SAAAD,GAAC,gBAAOA,EAAEtC,MAAT,kBAAkC,IAAVsC,EAAExC,MAA1B,eAAqD,IAARwC,EAAEzC,IAA/C,UAEXkC,EACKf,OAAO,KACPgB,UAAU,QACVC,MAAK,SAAAE,GAAC,OAAIA,EAAEC,kBAAkBI,eAC9BN,KAAK,QACLtB,KAAK,KAAK,SAAA6B,GAAC,OAAI5B,EAAE4B,EAAEC,UACnB9B,KAAK,IAAKtC,EAAW8B,UAAY,GACjCQ,KAAK,SAAUtC,EAAW8B,UAAY,GACtCQ,KAAK,QAAStC,EAAW8B,UAAY,GACrCQ,KAAK,QAAQ,SAAA6B,GAAC,OAAIX,EAAS,GAAD,OAAIW,EAAEE,gBAChC3B,OAAO,SACPuB,MAAK,SAAAE,GAAC,gBAAOA,EAAEE,WAAT,uBAA4C,IAAVF,EAAEC,MAApC,YAGgC,CAACzD,EAAQX,QCpFtDsE,EAAYC,aAAW,SAACC,GAAD,OAC3BC,YAAa,CACXC,QAAS,GACT5E,MAAO,CACL6E,SAAU,Q,4CAMhB,8BAAAC,EAAA,sEACoBC,MAAM,kBAD1B,cACQC,EADR,gBAEyCA,EAAIC,OAF7C,cAEQC,EAFR,yBAGSA,EAAQnF,KAAI,SAAAc,GACjB,IAAMsE,EAAaC,KAAKC,MAAMxE,EAAOyE,QACrC,OAAO,aAAEH,QAAStE,OALtB,4C,sBAqBA,IAIM0E,EAAY,CAChBC,GAAI,UACJjG,SAAU,SAAC2F,GACTO,QAAQC,IAAIR,GACZ,IAAM3F,EAAWoG,YAAMT,GAAS,SAAAnB,GAE9B,OADA0B,QAAQC,WAAW3B,EAAEoB,MACdpB,EAAEoB,KAAKvE,QAEhB,OAAOgF,MAAMC,KAAKtG,GAAUuG,SAAQ,YAAoB,IAAD,mBAAjB9F,EAAiB,KAAVC,EAAU,KACrD,MAAO,CACLD,QACAG,UAAU,EACVD,WAAY,CACV8B,UAjBQ,GAkBRD,WAAYQ,IAAOtC,GAAM,SAAA8D,GAAC,OAAIA,EAAEC,kBAAkB+B,OAClDtC,YAAalB,IAAOtC,GAAM,SAAA8D,GAAC,OAAIA,EAAEC,kBAAkBpC,UAErD3B,KAAMA,EAAKF,KAAI,SAAAc,GAEb,MAAO,CAAED,KADIC,EAAOsE,KAAKa,IACVnF,aACdoF,MAAK,SAACnB,EAAGoB,GACV,OAAIpB,EAAElE,OAASsF,EAAEtF,KACR,EAELkE,EAAElE,KAAOsF,EAAEtF,MA1BR,aA0BgBkE,EAAElE,MACf,GAEV6E,QAAQU,OAAOrB,EAAElE,KAAOsF,EAAEtF,MA7BnB,aA6B2BsF,EAAEtF,MAC7B,UAGVqF,MAAK,SAACnB,EAAGoB,GACV,OAAIpB,EAAE9E,QAAUkG,EAAElG,MACT,EAEL8E,EAAE9E,MAAQkG,EAAElG,OACN,EAEH,OAKPoG,EAAQ,CACZZ,GAAI,MACJjG,SAAU,SAAC2F,GACT,IAAM3F,EAAWoG,YAAMT,GAAS,SAAAnB,GAAC,OAAIA,EAAEoB,KAAKa,OACtC9F,EAAa,CACjB8B,UApDY,GAqDZD,WAAYQ,IAAO2C,GAAS,SAAAnB,GAAC,OAAIA,EAAEC,kBAAkB+B,OACrDtC,YAAalB,IAAO2C,GAAS,SAAAnB,GAAC,OAAIA,EAAEC,kBAAkBpC,UAExD,OAAOgE,MAAMC,KAAKtG,GAAUuG,SAAQ,WAAgBO,GAAO,IAAD,mBAApBrG,EAAoB,KAAbC,EAAa,KACxD,MAAO,CACLD,QACAG,UAAU,EACVD,aACAD,KAAMA,EAAKF,KAAI,SAAAc,GAEb,MAAO,CAAED,KADIC,EAAOsE,KAAKvE,KACVC,aACdoF,MAAK,SAACnB,EAAGoB,GACV,OAAIpB,EAAElE,KAAOsF,EAAEtF,MACL,GAEV6E,QAAQU,OAAOrB,EAAElE,KAAOsF,EAAEtF,MACnB,UAGVqF,MAAK,SAACnB,EAAGoB,GACV,OAAIpB,EAAE9E,QAAUkG,EAAElG,MACT,EAEL8E,EAAE9E,MAAQkG,EAAElG,OA1EL,aA0Ec8E,EAAE9E,OACjB,GAEVyF,QAAQU,OAAOrB,EAAE9E,MAAQkG,EAAElG,OA7EhB,aA6EyBkG,EAAElG,OAC/B,QAgDEsG,EA3CH,WACV,IAAMC,EAAS/B,IADC,EAEcgC,mBAAmB,IAFjC,mBAETtB,EAFS,KAEAuB,EAFA,OAGgBD,mBAASJ,GAHzB,mBAGTM,EAHS,KAGCC,EAHD,KAKhBC,qBAAU,Y,2CACRC,GAAaC,KAAKL,KACjB,IAEH,IAAMM,EAAkBL,IAAaN,EAASb,EAAYa,EAE1D,OACE,kBAAC,IAAMtF,SAAP,KACE,kBAACkG,EAAA,EAAD,MACA,kBAACC,EAAA,EAAD,CAAQC,SAAS,UACf,kBAACC,EAAA,EAAD,CAASC,UAAWb,EAAO3B,SACzB,kBAACrE,EAAA,EAAD,CAAYQ,QAAQ,KAAKqG,UAAWb,EAAOvG,OAA3C,4BAC4B0G,EAASlB,IAErC,kBAAC6B,EAAA,EAAD,CACEtG,QAAQ,YACRuG,MAAM,UACNC,QAAS,kBAAMZ,EAAYI,KAH7B,MAKMA,EAAevB,MAIzB,kBAAClF,EAAA,EAAD,CAAWkH,SAAS,MAClB,kBAAC/H,EAAA,EAAD,CAAMG,WAAS,EAACC,QAAS,GACvB,kBAACJ,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,GAAI8H,GAAI,EAAGpH,IAAI,WAC9B,kBAACZ,EAAA,EAAD,CAAMC,MAAI,EAACC,GAAI,GAAIU,IAAI,uBACrB,kBAAC,EAAD,CACEd,SAAUmH,EAASnH,SAAS2F,GAC5B1F,KAAMkI,SC5JAC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBxB,MAAK,SAAAyB,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLjD,QAAQiD,MAAMA,EAAMC,a","file":"static/js/main.40d68413.chunk.js","sourcesContent":["import React from \"react\";\nimport Container from \"@material-ui/core/Container\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Typography from \"@material-ui/core/Typography\";\n\nimport { Report } from \"./fortio\";\n\n// A group of report rows.\nexport type Section = {\n  title: string,\n  rows: Row[],\n  dimensions: Dimensions,\n  showAxis: boolean,\n};\n\n// A single report row.\nexport type Row = {\n  name: string,\n  report: Report,\n};\n\n\nexport type Dimensions = {\n  maxLatency: number,\n  maxRequests: number,\n  rowHeight: number,\n};\n\nexport type TopAxis = React.FC<Dimensions>;\nexport type VizProps = { report: Report, dimensions: Dimensions }\nexport type Viz = React.FC<VizProps>;\n\n// A strategy for rendering a section.\nexport type View = {\n  //\n  TopAxis: TopAxis, Viz: Viz\n};\n\ntype Props = {\n  sections: Section[],\n  view: View,\n};\n\nconst ReportGrid = ({ sections, view }: Props) => {\n  return (\n    <Grid item sm={12}>\n      <Grid container spacing={3} direction='row'>\n        {sections.map(({ title, rows, dimensions, showAxis }) => {\n          return (\n            <Grid item sm={12} lg={6} key={`${title} `}>\n              <Container>\n                <Grid container direction='column'>\n                  <Grid container item sm={12}>\n                    <Grid item sm={2} key='run'>\n                      <Container>\n                        <Typography>{title}</Typography>\n                      </Container>\n                    </Grid>\n                    <Grid item sm={10} key='top-axis'>\n                      {showAxis && <Paper square><view.TopAxis {...dimensions} /></Paper>}\n                    </Grid>\n                  </Grid>\n                  <Grid container item sm={12} alignItems='flex-start' direction='row'>\n                    {rows.map(({ name, report }) => {\n                      return (\n                        <React.Fragment key={name}>\n                          <Grid item container sm={2} direction='row'>\n                            <Grid item sm={1}></Grid>\n                            <Grid item sm={11}>\n                              <Container>\n                                <Typography variant='caption'>{name}</Typography>\n                              </Container>\n                            </Grid>\n                          </Grid>\n                          <Grid item sm={10}>\n                            <Paper square>\n                              <view.Viz report={report} dimensions={dimensions} />\n                            </Paper>\n                          </Grid>\n                        </React.Fragment>\n                      );\n                    })}\n                  </Grid>\n                </Grid>\n              </Container>\n            </Grid>\n          );\n        })}\n      </Grid>\n    </Grid>\n  );\n};\n\nexport default ReportGrid;\n","import * as d3 from \"d3\";\nimport React from \"react\";\nimport styled from \"@emotion/styled\";\n\nimport { Bucket } from './fortio';\nimport * as ReportGrid from './ReportGrid';\n\nconst SvgStyled = styled.svg`\n  height: 100%;\n  width: 100%;\n  //background-color: #666;\n`;\n\nexport const TopAxis: ReportGrid.TopAxis = ({ maxLatency, rowHeight }) => {\n    const draw = (element: SVGSVGElement) => {\n        if (element === null || !maxLatency) {\n            return;\n        }\n\n        const { width } = element.getBoundingClientRect();\n        const svg = d3\n            .select(element)\n            //.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n            .attr(\"preserveAspectRatio\", \"none\")\n            .attr(\"viewBox\", `0 0 ${width} ${rowHeight * 1.5}`);\n\n        const x = d3\n            .scaleLinear()\n            .domain([0, maxLatency!])\n            .rangeRound([15, width - 15]);\n\n        svg.append(\"g\").call(g => {\n            g.attr(\"transform\", `translate(0,${rowHeight * 1.5})`)\n                .call(\n                    d3.axisTop(x)\n                        .tickSize(rowHeight / 2)\n                        .tickFormat(n => `${n.valueOf() * 1000}ms`)\n                )\n        });\n    };\n\n    return <SvgStyled ref={React.useCallback(draw, [maxLatency, rowHeight])} />;\n};\n\nexport const HeatMap: ReportGrid.Viz = ({ report, dimensions }) => {\n    const draw = (element: SVGSVGElement) => {\n        if (report === undefined || element === null) {\n            return;\n        }\n        const { width } = element.getBoundingClientRect();\n\n        const x = d3\n            .scaleLinear()\n            .domain([0, dimensions.maxLatency!])\n            .rangeRound([15, width - 15]);\n\n        const svg = d3\n            .select(element)\n            .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n            .attr(\"viewBox\", `0 0 ${width} ${dimensions.rowHeight}`);\n\n        const scale = (latency: number) => Math.pow(latency, 1 / 4);\n        const boxColor = d3\n            .scaleSequential(d3.interpolateGreens)\n            .domain([0, scale(dimensions.maxRequests!)]);\n        const barColor = d3\n            .scaleOrdinal(d3.schemeYlOrRd[5])\n            .domain([\"50\", \"75\", \"90\", \"99\", \"99.9\"]);\n\n        const row = svg\n            .append(\"g\")\n            .attr(\"transform\", `translate(0,0)`)\n            .selectAll(\"g\")\n            .data([report])\n            .join(\"g\");\n\n        row\n            .append(\"g\")\n            .selectAll(\"rect\")\n            .data(r => fillGaps(r.DurationHistogram.Data))\n            .join(\"rect\")\n            .attr(\"x\", d => x(d.Start) + 1)\n            .attr(\"width\", d => x(d.End) - x(d.Start))\n            .attr(\"height\", dimensions.rowHeight)\n            .attr(\"fill\", d => boxColor(scale(d.Count)))\n            .append(\"title\")\n            .text(d => `${d.Count} reqs [${d.Start * 1000}ms..${d.End * 1000}ms)`);\n\n        row\n            .append(\"g\")\n            .selectAll(\"rect\")\n            .data(r => r.DurationHistogram.Percentiles)\n            .join(\"rect\")\n            .attr(\"x\", p => x(p.Value))\n            .attr(\"y\", dimensions.rowHeight / 3)\n            .attr(\"height\", dimensions.rowHeight / 3)\n            .attr(\"width\", dimensions.rowHeight / 6)\n            .attr(\"fill\", p => barColor(`${p.Percentile}`))\n            .append(\"title\")\n            .text(p => `${p.Percentile} percentile ${p.Value * 1000}ms`);\n    };\n\n    return <SvgStyled ref={React.useCallback(draw, [report, dimensions])} />;\n};\n\nconst fillGaps = (original: Bucket[]) => {\n    let filled: Bucket[] = [];\n    for (let bucket of original) {\n        // If there's a gap between the prior bucket and this one, insert an empty bucket in the gap.\n        if (filled.length > 0 && filled[filled.length - 1].End < bucket.Start) {\n            filled.push({\n                Start: filled[filled.length - 1].End,\n                End: bucket.Start,\n                Count: 0,\n                Percent: 0,\n            });\n        }\n        filled.push(bucket);\n    }\n    return filled;\n};\n\nexport const View: ReportGrid.View = {\n    TopAxis,\n    Viz: HeatMap,\n};\n\nexport default View;\n","import * as d3 from \"d3\";\nimport { group } from \"d3-array\"\nimport React, { useEffect, useState, } from \"react\";\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Button from '@material-ui/core/Button';\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport Container from \"@material-ui/core/Container\";\nimport Grid from \"@material-ui/core/Grid\";\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\n\nimport * as fortio from \"./fortio\";\nimport ReportGrid, { Section } from './ReportGrid'\nimport RequestsByLatency from './RequestsByLatency'\n//import LatencyByRequests from './LatencyByRequests'\n\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    toolbar: {},\n    title: {\n      flexGrow: 1,\n    },\n  }),\n);\n\n// Fetches a list of test results from the server.\nasync function getReports() {\n  const rsp = await fetch(\"./reports.json\");\n  const reports: fortio.Report[] = await rsp.json();\n  return reports.map(report => {\n    const meta: Meta = JSON.parse(report.Labels);\n    return { meta, ...report };\n  });\n}\n\ntype Meta = {\n  name: string,\n  run: string,\n};\ntype Report = fortio.Report & {\n  meta: Meta,\n};\n\ninterface Grouping {\n  sections(reports: Report[]): Section[];\n};\n\nconst RowHeight = 20;\n\nconst Baseline = \"baseline\";\n\nconst byProfile = {\n  by: \"Profile\",\n  sections: (reports: Report[]) => {\n    console.log(reports);\n    const sections = group(reports, r => {\n      console.log(typeof r.meta);\n      return r.meta.name;\n    });\n    return Array.from(sections).flatMap(([title, rows]) => {\n      return {\n        title,\n        showAxis: true,\n        dimensions: {\n          rowHeight: RowHeight,\n          maxLatency: d3.max(rows, r => r.DurationHistogram.Max)!,\n          maxRequests: d3.max(rows, r => r.DurationHistogram.Count)!,\n        },\n        rows: rows.map(report => {\n          const name = report.meta.run;\n          return { name, report };\n        }).sort((a, b) => {\n          if (a.name === b.name) {\n            return 0;\n          }\n          if (a.name < b.name || a.name === Baseline) {\n            return -1;\n          }\n          console.assert(a.name > b.name || b.name === Baseline);\n          return 1;\n        }),\n      };\n    }).sort((a, b) => {\n      if (a.title === b.title) {\n        return 0;\n      }\n      if (a.title < b.title) {\n        return -1;\n      }\n      return 1;\n    });\n  },\n};\n\nconst byRun = {\n  by: \"Run\",\n  sections: (reports: Report[]) => {\n    const sections = group(reports, r => r.meta.run);\n    const dimensions = {\n      rowHeight: RowHeight,\n      maxLatency: d3.max(reports, r => r.DurationHistogram.Max)!,\n      maxRequests: d3.max(reports, r => r.DurationHistogram.Count)!,\n    };\n    return Array.from(sections).flatMap(([title, rows], i) => {\n      return {\n        title,\n        showAxis: true, //i === 0,\n        dimensions,\n        rows: rows.map(report => {\n          const name = report.meta.name;\n          return { name, report };\n        }).sort((a, b) => {\n          if (a.name < b.name) {\n            return -1;\n          }\n          console.assert(a.name > b.name);\n          return 1;\n        }),\n      };\n    }).sort((a, b) => {\n      if (a.title === b.title) {\n        return 0;\n      }\n      if (a.title < b.title || a.title === Baseline) {\n        return -1;\n      }\n      console.assert(a.title > b.title || b.title === Baseline);\n      return 1;\n    });\n  },\n};\n\nconst App = () => {\n  const styles = useStyles();\n  const [reports, setReports] = useState<Report[]>([]);\n  const [grouping, setGrouping] = useState(byRun);\n\n  useEffect(() => {\n    getReports().then(setReports);\n  }, []);\n\n  const unusedGrouping = (grouping === byRun) ? byProfile : byRun;\n\n  return (\n    <React.Fragment>\n      <CssBaseline />\n      <AppBar position=\"static\">\n        <Toolbar className={styles.toolbar}>\n          <Typography variant=\"h6\" className={styles.title}>\n            Proxy Latency Profile by {grouping.by}\n          </Typography>\n          <Button\n            variant='contained'\n            color='inherit'\n            onClick={() => setGrouping(unusedGrouping)}\n          >\n            By {unusedGrouping.by}\n          </Button>\n        </Toolbar>\n      </AppBar>\n      <Container maxWidth='xl'>\n        <Grid container spacing={2}>\n          <Grid item sm={12} md={6} key='spacer'></Grid>\n          <Grid item sm={12} key='requests-by-latency'>\n            <ReportGrid\n              sections={grouping.sections(reports)}\n              view={RequestsByLatency}\n            />\n          </Grid>\n        </Grid>\n      </Container>\n    </React.Fragment >\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}